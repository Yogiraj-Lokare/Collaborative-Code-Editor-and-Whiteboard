[{"C:\\edi1\\react_type\\react-type\\src\\index.tsx":"1","C:\\edi1\\react_type\\react-type\\src\\reportWebVitals.ts":"2","C:\\edi1\\react_type\\react-type\\src\\App.tsx":"3","C:\\edi1\\react_type\\react-type\\src\\ot\\editor-client.js":"4","C:\\edi1\\react_type\\react-type\\src\\ot\\codemirror-adapter.js":"5","C:\\edi1\\react_type\\react-type\\src\\ot\\socketio-adapter.js":"6","C:\\edi1\\react_type\\react-type\\src\\socket\\socket.ts":"7","C:\\edi1\\react_type\\react-type\\src\\ot\\undo-manager.js":"8","C:\\edi1\\react_type\\react-type\\src\\ot\\client.js":"9","C:\\edi1\\react_type\\react-type\\src\\ot\\wrapped-operation.js":"10","C:\\edi1\\react_type\\react-type\\src\\ot\\text-operation.js":"11","C:\\edi1\\react_type\\react-type\\src\\ot\\selection.js":"12","C:\\edi1\\react_type\\react-type\\src\\utils\\WindowAddon.ts":"13","C:\\edi1\\react_type\\react-type\\src\\components\\codeEditor\\codeEditor.tsx":"14","C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\WhiteBoard.tsx":"15","C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\Containter.tsx":"16","C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\Board.tsx":"17","C:\\edi1\\react_type\\react-type\\src\\components\\Appbar\\Appbar.tsx":"18","C:\\edi1\\react_type\\react-type\\src\\components\\Footer\\Footer.tsx":"19","C:\\edi1\\react_type\\react-type\\src\\socket\\socketEvents.ts":"20","C:\\edi1\\react_type\\react-type\\src\\components\\Video\\Video.tsx":"21","C:\\edi1\\Collab\\frontend\\src\\index.tsx":"22","C:\\edi1\\Collab\\frontend\\src\\App.tsx":"23","C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\WhiteBoard.tsx":"24","C:\\edi1\\Collab\\frontend\\src\\components\\Appbar\\Appbar.tsx":"25","C:\\edi1\\Collab\\frontend\\src\\components\\codeEditor\\codeEditor.tsx":"26","C:\\edi1\\Collab\\frontend\\src\\components\\Video\\Video.tsx":"27","C:\\edi1\\Collab\\frontend\\src\\ot\\codemirror-adapter.js":"28","C:\\edi1\\Collab\\frontend\\src\\ot\\socketio-adapter.js":"29","C:\\edi1\\Collab\\frontend\\src\\ot\\editor-client.js":"30","C:\\edi1\\Collab\\frontend\\src\\socket\\socket.ts":"31","C:\\edi1\\Collab\\frontend\\src\\utils\\WindowAddon.ts":"32","C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\Containter.tsx":"33","C:\\edi1\\Collab\\frontend\\src\\ot\\selection.js":"34","C:\\edi1\\Collab\\frontend\\src\\ot\\text-operation.js":"35","C:\\edi1\\Collab\\frontend\\src\\ot\\wrapped-operation.js":"36","C:\\edi1\\Collab\\frontend\\src\\ot\\undo-manager.js":"37","C:\\edi1\\Collab\\frontend\\src\\ot\\client.js":"38","C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\Board.tsx":"39"},{"size":548,"mtime":1618302951967,"results":"40","hashOfConfig":"41"},{"size":425,"mtime":499162500000,"results":"42","hashOfConfig":"41"},{"size":808,"mtime":1618720264602,"results":"43","hashOfConfig":"41"},{"size":9841,"mtime":1618591311390,"results":"44","hashOfConfig":"41"},{"size":14926,"mtime":1618223427638,"results":"45","hashOfConfig":"41"},{"size":1308,"mtime":1617060463805,"results":"46","hashOfConfig":"41"},{"size":70,"mtime":1618236423646,"results":"47","hashOfConfig":"41"},{"size":3268,"mtime":1617256310525,"results":"48","hashOfConfig":"41"},{"size":6049,"mtime":1618582740714,"results":"49","hashOfConfig":"41"},{"size":1811,"mtime":1617182071338,"results":"50","hashOfConfig":"41"},{"size":17927,"mtime":1618583815870,"results":"51","hashOfConfig":"41"},{"size":3028,"mtime":1618223339969,"results":"52","hashOfConfig":"41"},{"size":438,"mtime":1618317532976,"results":"53","hashOfConfig":"41"},{"size":3282,"mtime":1618468368659,"results":"54","hashOfConfig":"41"},{"size":333,"mtime":1618319666597,"results":"55","hashOfConfig":"41"},{"size":2170,"mtime":1618646293948,"results":"56","hashOfConfig":"41"},{"size":3582,"mtime":1618720180406,"results":"57","hashOfConfig":"41"},{"size":516,"mtime":1618473869782,"results":"58","hashOfConfig":"41"},{"size":578,"mtime":1618468211978,"results":"59","hashOfConfig":"41"},{"size":313,"mtime":1618495390052,"results":"60","hashOfConfig":"41"},{"size":2472,"mtime":1618721062727,"results":"61","hashOfConfig":"41"},{"size":548,"mtime":1618302951967,"results":"62","hashOfConfig":"63"},{"size":808,"mtime":1618720264602,"results":"64","hashOfConfig":"63"},{"size":333,"mtime":1618319666597,"results":"65","hashOfConfig":"63"},{"size":516,"mtime":1618473869782,"results":"66","hashOfConfig":"63"},{"size":3282,"mtime":1618468368659,"results":"67","hashOfConfig":"63"},{"size":2472,"mtime":1618721062727,"results":"68","hashOfConfig":"63"},{"size":14926,"mtime":1618223427638,"results":"69","hashOfConfig":"63"},{"size":1308,"mtime":1617060463805,"results":"70","hashOfConfig":"63"},{"size":9841,"mtime":1618591311390,"results":"71","hashOfConfig":"63"},{"size":70,"mtime":1618236423646,"results":"72","hashOfConfig":"63"},{"size":438,"mtime":1618317532976,"results":"73","hashOfConfig":"63"},{"size":2170,"mtime":1618646293948,"results":"74","hashOfConfig":"63"},{"size":3028,"mtime":1618223339969,"results":"75","hashOfConfig":"63"},{"size":17927,"mtime":1618583815870,"results":"76","hashOfConfig":"63"},{"size":1811,"mtime":1617182071338,"results":"77","hashOfConfig":"63"},{"size":3268,"mtime":1617256310525,"results":"78","hashOfConfig":"63"},{"size":6049,"mtime":1618582740714,"results":"79","hashOfConfig":"63"},{"size":3582,"mtime":1618720180406,"results":"80","hashOfConfig":"63"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},"1h3i6vt",{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"86","messages":"87","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"83"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"92"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"92"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"92"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"92"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"83"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"83"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124","usedDeprecatedRules":"83"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"127","usedDeprecatedRules":"83"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"130","messages":"131","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"132"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"135","messages":"136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1y9rojf",{"filePath":"137","messages":"138","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"139","messages":"140","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"141","messages":"142","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"143","messages":"144","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"145","messages":"146","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"147","messages":"148","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"149","messages":"150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"151","messages":"152","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"157","messages":"158","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"159","messages":"160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"161","messages":"162","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"163","messages":"164","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"169","messages":"170","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\edi1\\react_type\\react-type\\src\\index.tsx",[],["171","172"],"C:\\edi1\\react_type\\react-type\\src\\reportWebVitals.ts",[],"C:\\edi1\\react_type\\react-type\\src\\App.tsx",["173","174","175","176","177","178"],"import React, { useState, useEffect, ChangeEvent } from \"react\";\nimport \"./App.css\";\nimport { Flex, FormControl, Select, Stack } from \"@chakra-ui/react\";\nimport CodeEditor from \"./components/codeEditor/codeEditor\";\nimport WhiteBoard from \"./components/whiteBoard/WhiteBoard\";\nimport AppHeaderBar from \"./components/Appbar/Appbar\";\nimport Footer from \"./components/Footer/Footer\";\nimport Video from \"./components/Video/Video\";\n\nconst App: React.FC = () => {\n  return (\n    <React.Fragment>\n      <AppHeaderBar />\n      <Flex alignItems=\"stretch\" alignContent=\"stretch\" direction=\"row\">\n        <Stack width=\"50vw\">\n          <CodeEditor />\n        </Stack>\n        <Stack width=\"50vw\">\n          <WhiteBoard />\n        </Stack>\n      </Flex>\n      <Video />\n    </React.Fragment>\n  );\n};\n\nexport default App;\n","C:\\edi1\\react_type\\react-type\\src\\ot\\editor-client.js",["179","180"],"import UndoManager from \"./undo-manager\";\nimport WrappedOperation from \"./wrapped-operation\";\nimport Client from \"./client\";\nimport TextOperation from \"./text-operation\";\nimport Selection from \"./selection\";\n//var Client = ot.Client;\n//var Selection = ot.Selection;\n//var UndoManager = ot.UndoManager;\n//var TextOperation = ot.TextOperation;\n//var WrappedOperation = ot.WrappedOperation;\n\nclass SelfMeta {\n  constructor(selectionBefore, selectionAfter) {\n    this.selectionBefore = selectionBefore;\n    this.selectionAfter = selectionAfter;\n  }\n  invert() {\n    return new SelfMeta(this.selectionAfter, this.selectionBefore);\n  }\n  compose(other) {\n    return new SelfMeta(this.selectionBefore, other.selectionAfter);\n  }\n  transform(operation) {\n    return new SelfMeta(\n      this.selectionBefore.transform(operation),\n      this.selectionAfter.transform(operation)\n    );\n  }\n}\n\nclass OtherMeta {\n  constructor(clientId, selection) {\n    this.clientId = clientId;\n    this.selection = selection;\n  }\n  transform(operation) {\n    return new OtherMeta(\n      this.clientId,\n      this.selection && this.selection.transform(operation)\n    );\n  }\n  static fromJSON(obj) {\n    return new OtherMeta(\n      obj.clientId,\n      obj.selection && Selection.fromJSON(obj.selection)\n    );\n  }\n}\n\nclass OtherClient {\n  constructor(id, listEl, editorAdapter, name, selection) {\n    this.id = id;\n    this.listEl = listEl;\n    this.editorAdapter = editorAdapter;\n    this.name = name;\n\n    this.li = document.createElement(\"li\");\n    if (name) {\n      this.li.textContent = name;\n      this.listEl.appendChild(this.li);\n    }\n\n    this.setColor(name ? hueFromName(name) : Math.random());\n    if (selection) {\n      this.updateSelection(selection);\n    }\n  }\n  setColor(hue) {\n    this.hue = hue;\n    this.color = hsl2hex(hue, 0.75, 0.5);\n    this.lightColor = hsl2hex(hue, 0.5, 0.9);\n    if (this.li) {\n      this.li.style.color = this.color;\n    }\n  }\n  setName(name) {\n    if (this.name === name) {\n      return;\n    }\n    this.name = name;\n\n    this.li.textContent = name;\n    if (!this.li.parentNode) {\n      this.listEl.appendChild(this.li);\n    }\n\n    this.setColor(hueFromName(name));\n  }\n  updateSelection(selection) {\n    this.removeSelection();\n    this.selection = selection;\n    this.mark = this.editorAdapter.setOtherSelection(\n      selection,\n      selection.position === selection.selectionEnd\n        ? this.color\n        : this.lightColor,\n      this.id\n    );\n  }\n  remove() {\n    if (this.li) {\n      removeElement(this.li);\n    }\n    this.removeSelection();\n  }\n  removeSelection() {\n    if (this.mark) {\n      this.mark.clear();\n      this.mark = null;\n    }\n  }\n}\n\nclass EditorClient extends Client {\n  constructor(revision, clients, serverAdapter, editorAdapter) {\n    //Client.call(this, revision);\n    super(revision);\n    //super(this,revision);\n    this.serverAdapter = serverAdapter;\n    this.editorAdapter = editorAdapter;\n    this.undoManager = new UndoManager();\n\n    this.initializeClientList();\n    this.initializeClients(clients);\n\n    var self = this;\n\n    this.editorAdapter.registerCallbacks({\n      change: function (operation, inverse) {\n        self.onChange(operation, inverse);\n      },\n      selectionChange: function () {\n        self.onSelectionChange();\n      },\n      blur: function () {\n        self.onBlur();\n      },\n    });\n    this.editorAdapter.registerUndo(function () {\n      self.undo();\n    });\n    this.editorAdapter.registerRedo(function () {\n      self.redo();\n    });\n\n    this.serverAdapter.registerCallbacks({\n      client_left: function (clientId) {\n        self.onClientLeft(clientId);\n      },\n      set_name: function (clientId, name) {\n        self.getClientObject(clientId).setName(name);\n      },\n      ack: function () {\n        self.serverAck();\n      },\n      operation: function (operation) {\n        self.applyServer(TextOperation.fromJSON(operation));\n      },\n      selection: function (clientId, selection) {\n        if (selection) {\n          self\n            .getClientObject(clientId)\n            .updateSelection(\n              self.transformSelection(Selection.fromJSON(selection))\n            );\n        } else {\n          self.getClientObject(clientId).removeSelection();\n        }\n      },\n      clients: function (clients) {\n        var clientId;\n        for (clientId in self.clients) {\n          if (\n            self.clients.hasOwnProperty(clientId) &&\n            !clients.hasOwnProperty(clientId)\n          ) {\n            self.onClientLeft(clientId);\n          }\n        }\n\n        for (clientId in clients) {\n          if (clients.hasOwnProperty(clientId)) {\n            var clientObject = self.getClientObject(clientId);\n\n            if (clients[clientId].name) {\n              clientObject.setName(clients[clientId].name);\n            }\n\n            var selection = clients[clientId].selection;\n            if (selection) {\n              self.clients[clientId].updateSelection(\n                self.transformSelection(Selection.fromJSON(selection))\n              );\n            } else {\n              self.clients[clientId].removeSelection();\n            }\n          }\n        }\n      },\n      reconnect: function () {\n        self.serverReconnect();\n      },\n    });\n    //this.revision = undefined;\n  }\n  addClient(clientId, clientObj) {\n    this.clients[clientId] = new OtherClient(\n      clientId,\n      this.clientListEl,\n      this.editorAdapter,\n      clientObj.name || clientId,\n      clientObj.selection ? Selection.fromJSON(clientObj.selection) : null\n    );\n  }\n  initializeClients(clients) {\n    this.clients = {};\n    for (var clientId in clients) {\n      if (clients.hasOwnProperty(clientId)) {\n        this.addClient(clientId, clients[clientId]);\n      }\n    }\n  }\n  getClientObject(clientId) {\n    var client = this.clients[clientId];\n    if (client) {\n      return client;\n    }\n    return (this.clients[clientId] = new OtherClient(\n      clientId,\n      this.clientListEl,\n      this.editorAdapter\n    ));\n  }\n  onClientLeft(clientId) {\n    console.log(\"User disconnected: \" + clientId);\n    var client = this.clients[clientId];\n    if (!client) {\n      return;\n    }\n    client.remove();\n    delete this.clients[clientId];\n  }\n  initializeClientList() {\n    this.clientListEl = document.createElement(\"ul\");\n  }\n  applyUnredo(operation) {\n    this.undoManager.add(operation.invert(this.editorAdapter.getValue()));\n    this.editorAdapter.applyOperation(operation.wrapped);\n    this.selection = operation.meta.selectionAfter;\n    this.editorAdapter.setSelection(this.selection);\n    this.applyClient(operation.wrapped);\n  }\n  undo() {\n    var self = this;\n    if (!this.undoManager.canUndo()) {\n      return;\n    }\n    this.undoManager.performUndo(function (o) {\n      self.applyUnredo(o);\n    });\n  }\n  redo() {\n    var self = this;\n    if (!this.undoManager.canRedo()) {\n      return;\n    }\n    this.undoManager.performRedo(function (o) {\n      self.applyUnredo(o);\n    });\n  }\n  onChange(textOperation, inverse) {\n    var selectionBefore = this.selection;\n    this.updateSelection();\n    var meta = new SelfMeta(selectionBefore, this.selection);\n    var operation = new WrappedOperation(textOperation, meta);\n\n    var compose =\n      this.undoManager.undoStack.length > 0 &&\n      inverse.shouldBeComposedWithInverted(\n        last(this.undoManager.undoStack).wrapped\n      );\n    var inverseMeta = new SelfMeta(this.selection, selectionBefore);\n    this.undoManager.add(new WrappedOperation(inverse, inverseMeta), compose);\n    this.applyClient(textOperation);\n  }\n  updateSelection() {\n    this.selection = this.editorAdapter.getSelection();\n  }\n  onSelectionChange() {\n    var oldSelection = this.selection;\n    this.updateSelection();\n    if (oldSelection && this.selection.equals(oldSelection)) {\n      return;\n    }\n    this.sendSelection(this.selection);\n  }\n  onBlur() {\n    this.selection = null;\n    this.sendSelection(null);\n  }\n  sendSelection(selection) {\n    if (this.state instanceof Client.AwaitingWithBuffer) {\n      return;\n    }\n    this.serverAdapter.sendSelection(selection);\n  }\n  sendOperation(revision, operation) {\n    this.serverAdapter.sendOperation(\n      revision,\n      operation.toJSON(),\n      this.selection\n    );\n  }\n  applyOperation(operation) {\n    this.editorAdapter.applyOperation(operation);\n    this.updateSelection();\n    this.undoManager.transform(new WrappedOperation(operation, null));\n  }\n}\n\n//inherit(EditorClient, Client);\n\nfunction rgb2hex(r, g, b) {\n  function digits(n) {\n    var m = Math.round(255 * n).toString(16);\n    return m.length === 1 ? \"0\" + m : m;\n  }\n  return \"#\" + digits(r) + digits(g) + digits(b);\n}\n\nfunction hsl2hex(h, s, l) {\n  if (s === 0) {\n    return rgb2hex(l, l, l);\n  }\n  var var2 = l < 0.5 ? l * (1 + s) : l + s - s * l;\n  var var1 = 2 * l - var2;\n  var hue2rgb = function (hue) {\n    if (hue < 0) {\n      hue += 1;\n    }\n    if (hue > 1) {\n      hue -= 1;\n    }\n    if (6 * hue < 1) {\n      return var1 + (var2 - var1) * 6 * hue;\n    }\n    if (2 * hue < 1) {\n      return var2;\n    }\n    if (3 * hue < 2) {\n      return var1 + (var2 - var1) * 6 * (2 / 3 - hue);\n    }\n    return var1;\n  };\n  return rgb2hex(hue2rgb(h + 1 / 3), hue2rgb(h), hue2rgb(h - 1 / 3));\n}\n\nfunction hueFromName(name) {\n  var a = 1;\n  for (var i = 0; i < name.length; i++) {\n    a = (17 * (a + name.charCodeAt(i))) % 360;\n  }\n  return a / 360;\n}\n\n// Set Const.prototype.__proto__ to Super.prototype\n// function inherit (Const, Super) {\n//   function F () {}\n//   F.prototype = Super.prototype;\n//   Const.prototype = new F();\n//   Const.prototype.constructor = Const;\n// }\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\n// Remove an element from the DOM.\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n}\n\nexport default EditorClient;\n",["181","182"],"C:\\edi1\\react_type\\react-type\\src\\ot\\codemirror-adapter.js",["183","184"],"import Selection from \"./selection\";\nimport TextOperation from \"./text-operation\";\nclass CodeMirrorAdapter {\n  constructor(cm) {\n    this.cm = cm;\n    this.ignoreNextChange = false;\n    this.changeInProgress = false;\n    this.selectionChanged = false;\n\n    bind(this, \"onChanges\");\n    bind(this, \"onChange\");\n    bind(this, \"onCursorActivity\");\n    bind(this, \"onFocus\");\n    bind(this, \"onBlur\");\n\n    cm.on(\"changes\", this.onChanges);\n    cm.on(\"change\", this.onChange);\n    cm.on(\"cursorActivity\", this.onCursorActivity);\n    cm.on(\"focus\", this.onFocus);\n    cm.on(\"blur\", this.onBlur);\n  }\n  // Removes all event listeners from the CodeMirror instance.\n  detach() {\n    this.cm.off(\"changes\", this.onChanges);\n    this.cm.off(\"change\", this.onChange);\n    this.cm.off(\"cursorActivity\", this.onCursorActivity);\n    this.cm.off(\"focus\", this.onFocus);\n    this.cm.off(\"blur\", this.onBlur);\n  }\n  registerCallbacks(cb) {\n    this.callbacks = cb;\n  }\n  onChange() {\n    // By default, CodeMirror's event order is the following:\n    // 1. 'change', 2. 'cursorActivity', 3. 'changes'.\n    // We want to fire the 'selectionChange' event after the 'change' event,\n    // but need the information from the 'changes' event. Therefore, we detect\n    // when a change is in progress by listening to the change event, setting\n    // a flag that makes this adapter defer all 'cursorActivity' events.\n    this.changeInProgress = true;\n  }\n  onChanges(_, changes) {\n    if (!this.ignoreNextChange) {\n      var pair = CodeMirrorAdapter.operationFromCodeMirrorChanges(\n        changes,\n        this.cm\n      );\n      this.trigger(\"change\", pair[0], pair[1]);\n    }\n    if (this.selectionChanged) {\n      this.trigger(\"selectionChange\");\n    }\n    this.changeInProgress = false;\n    this.ignoreNextChange = false;\n  }\n  onCursorActivity() {\n    if (this.changeInProgress) {\n      this.selectionChanged = true;\n    } else {\n      this.trigger(\"selectionChange\");\n    }\n  }\n  onFocus() {\n    if (this.changeInProgress) {\n      this.selectionChanged = true;\n    } else {\n      this.trigger(\"selectionChange\");\n    }\n  }\n  onBlur() {\n    if (!this.cm.somethingSelected()) {\n      this.trigger(\"blur\");\n    }\n  }\n  getValue() {\n    return this.cm.getValue();\n  }\n  getSelection() {\n    var cm = this.cm;\n\n    var selectionList = cm.listSelections();\n    var ranges = [];\n    for (var i = 0; i < selectionList.length; i++) {\n      ranges[i] = new Selection.Range(\n        cm.indexFromPos(selectionList[i].anchor),\n        cm.indexFromPos(selectionList[i].head)\n      );\n    }\n\n    return new Selection(ranges);\n  }\n  setSelection(selection) {\n    var ranges = [];\n    for (var i = 0; i < selection.ranges.length; i++) {\n      var range = selection.ranges[i];\n      ranges[i] = {\n        anchor: this.cm.posFromIndex(range.anchor),\n        head: this.cm.posFromIndex(range.head),\n      };\n    }\n    this.cm.setSelections(ranges);\n  }\n  setOtherCursor(position, color, clientId) {\n    var cursorPos = this.cm.posFromIndex(position);\n    var cursorCoords = this.cm.cursorCoords(cursorPos);\n    var cursorEl = document.createElement(\"span\");\n\n    cursorEl.style.position = \"absolute\";\n    cursorEl.style.pointerEvents = \"none\";\n    cursorEl.style.zIndex = 4000;\n    cursorEl.style.width = \"2px\";\n    //cursorEl.className = '';\n    cursorEl.style.display = \"inline-block\";\n    // cursorEl.style.padding = '0';\n    cursorEl.style.marginLeft = cursorEl.style.marginRight = \"-1px\";\n    cursorEl.style.borderLeftWidth = \"2px\";\n    cursorEl.style.borderLeftStyle = \"solid\";\n    cursorEl.style.borderLeftColor = color;\n    cursorEl.style.height =\n      (cursorCoords.bottom - cursorCoords.top) * 0.9 + \"px\";\n    // cursorEl.style.zIndex = 0;\n    cursorEl.setAttribute(\"data-clientid\", clientId);\n    return this.cm.setBookmark(cursorPos, {\n      widget: cursorEl,\n      insertLeft: true,\n    });\n  }\n  setOtherSelectionRange(range, color, clientId) {\n    var match = /^#([0-9a-fA-F]{6})$/.exec(color);\n    if (!match) {\n      throw new Error(\"only six-digit hex colors are allowed.\");\n    }\n    var selectionClassName = \"selection-\" + match[1];\n    var rule = \".\" + selectionClassName + \" { background: \" + color + \"; }\";\n    addStyleRule(rule);\n\n    var anchorPos = this.cm.posFromIndex(range.anchor);\n    var headPos = this.cm.posFromIndex(range.head);\n\n    return this.cm.markText(\n      minPos(anchorPos, headPos),\n      maxPos(anchorPos, headPos),\n      { className: selectionClassName }\n    );\n  }\n  setOtherSelection(selection, color, clientId) {\n    var selectionObjects = [];\n    for (var i = 0; i < selection.ranges.length; i++) {\n      var range = selection.ranges[i];\n      if (range.isEmpty()) {\n        selectionObjects[i] = this.setOtherCursor(range.head, color, clientId);\n      } else {\n        selectionObjects[i] = this.setOtherSelectionRange(\n          range,\n          color,\n          clientId\n        );\n      }\n    }\n    return {\n      clear: function () {\n        for (var i = 0; i < selectionObjects.length; i++) {\n          selectionObjects[i].clear();\n        }\n      },\n    };\n  }\n  trigger(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    var action = this.callbacks && this.callbacks[event];\n    if (action) {\n      action.apply(this, args);\n    }\n  }\n  applyOperation(operation) {\n    this.ignoreNextChange = true;\n    CodeMirrorAdapter.applyOperationToCodeMirror(operation, this.cm);\n  }\n  registerUndo(undoFn) {\n    this.cm.undo = undoFn;\n  }\n  registerRedo(redoFn) {\n    this.cm.redo = redoFn;\n  }\n  // Converts a CodeMirror change array (as obtained from the 'changes' event\n  // in CodeMirror v4) or single change or linked list of changes (as returned\n  // by the 'change' event in CodeMirror prior to version 4) into a\n  // TextOperation and its inverse and returns them as a two-element array.\n  static operationFromCodeMirrorChanges(changes, doc) {\n    // Approach: Replay the changes, beginning with the most recent one, and\n    // construct the operation and its inverse. We have to convert the position\n    // in the pre-change coordinate system to an index. We have a method to\n    // convert a position in the coordinate system after all changes to an index,\n    // namely CodeMirror's `indexFromPos` method. We can use the information of\n    // a single change object to convert a post-change coordinate system to a\n    // pre-change coordinate system. We can now proceed inductively to get a\n    // pre-change coordinate system for all changes in the linked list.\n    // A disadvantage of this approach is its complexity `O(n^2)` in the length\n    // of the linked list of changes.\n    var docEndLength = codemirrorDocLength(doc);\n    var operation = new TextOperation().retain(docEndLength);\n    var inverse = new TextOperation().retain(docEndLength);\n\n    var indexFromPos = function (pos) {\n      return doc.indexFromPos(pos);\n    };\n\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    function sumLengths(strArr) {\n      if (strArr.length === 0) {\n        return 0;\n      }\n      var sum = 0;\n      for (var i = 0; i < strArr.length; i++) {\n        sum += strArr[i].length;\n      }\n      return sum + strArr.length - 1;\n    }\n\n    function updateIndexFromPos(indexFromPos, change) {\n      return function (pos) {\n        if (posLe(pos, change.from)) {\n          return indexFromPos(pos);\n        }\n        if (posLe(change.to, pos)) {\n          return (\n            indexFromPos({\n              line:\n                pos.line +\n                change.text.length -\n                1 -\n                (change.to.line - change.from.line),\n              ch:\n                change.to.line < pos.line\n                  ? pos.ch\n                  : change.text.length <= 1\n                  ? pos.ch -\n                    (change.to.ch - change.from.ch) +\n                    sumLengths(change.text)\n                  : pos.ch - change.to.ch + last(change.text).length,\n            }) +\n            sumLengths(change.removed) -\n            sumLengths(change.text)\n          );\n        }\n        if (change.from.line === pos.line) {\n          return indexFromPos(change.from) + pos.ch - change.from.ch;\n        }\n        return (\n          indexFromPos(change.from) +\n          sumLengths(change.removed.slice(0, pos.line - change.from.line)) +\n          1 +\n          pos.ch\n        );\n      };\n    }\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      var change = changes[i];\n      indexFromPos = updateIndexFromPos(indexFromPos, change);\n\n      var fromIndex = indexFromPos(change.from);\n      var restLength = docEndLength - fromIndex - sumLengths(change.text);\n\n      operation = new TextOperation()\n        .retain(fromIndex)\n        [\"delete\"](sumLengths(change.removed))\n        .insert(change.text.join(\"\\n\"))\n        .retain(restLength)\n        .compose(operation);\n\n      inverse = inverse.compose(\n        new TextOperation()\n          .retain(fromIndex)\n          [\"delete\"](sumLengths(change.text))\n          .insert(change.removed.join(\"\\n\"))\n          .retain(restLength)\n      );\n\n      docEndLength += sumLengths(change.removed) - sumLengths(change.text);\n    }\n\n    return [operation, inverse];\n  }\n  // Apply an operation to a CodeMirror instance.\n  static applyOperationToCodeMirror(operation, cm) {\n    cm.operation(function () {\n      var ops = operation.ops;\n      var index = 0; // holds the current index into CodeMirror's content\n      for (var i = 0, l = ops.length; i < l; i++) {\n        var op = ops[i];\n        if (TextOperation.isRetain(op)) {\n          index += op;\n        } else if (TextOperation.isInsert(op)) {\n          cm.replaceRange(op, cm.posFromIndex(index));\n          index += op.length;\n        } else if (TextOperation.isDelete(op)) {\n          var from = cm.posFromIndex(index);\n          var to = cm.posFromIndex(index - op);\n          cm.replaceRange(\"\", from, to);\n        }\n      }\n    });\n  }\n  static operationFromCodeMirrorChange(changes, doc) {\n    // Approach: Replay the changes, beginning with the most recent one, and\n    // construct the operation and its inverse. We have to convert the position\n    // in the pre-change coordinate system to an index. We have a method to\n    // convert a position in the coordinate system after all changes to an index,\n    // namely CodeMirror's `indexFromPos` method. We can use the information of\n    // a single change object to convert a post-change coordinate system to a\n    // pre-change coordinate system. We can now proceed inductively to get a\n    // pre-change coordinate system for all changes in the linked list.\n    // A disadvantage of this approach is its complexity `O(n^2)` in the length\n    // of the linked list of changes.\n    var docEndLength = codemirrorDocLength(doc);\n    var operation = new TextOperation().retain(docEndLength);\n    var inverse = new TextOperation().retain(docEndLength);\n\n    var indexFromPos = function (pos) {\n      return doc.indexFromPos(pos);\n    };\n\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    function sumLengths(strArr) {\n      if (strArr.length === 0) {\n        return 0;\n      }\n      var sum = 0;\n      for (var i = 0; i < strArr.length; i++) {\n        sum += strArr[i].length;\n      }\n      return sum + strArr.length - 1;\n    }\n\n    function updateIndexFromPos(indexFromPos, change) {\n      return function (pos) {\n        if (posLe(pos, change.from)) {\n          return indexFromPos(pos);\n        }\n        if (posLe(change.to, pos)) {\n          return (\n            indexFromPos({\n              line:\n                pos.line +\n                change.text.length -\n                1 -\n                (change.to.line - change.from.line),\n              ch:\n                change.to.line < pos.line\n                  ? pos.ch\n                  : change.text.length <= 1\n                  ? pos.ch -\n                    (change.to.ch - change.from.ch) +\n                    sumLengths(change.text)\n                  : pos.ch - change.to.ch + last(change.text).length,\n            }) +\n            sumLengths(change.removed) -\n            sumLengths(change.text)\n          );\n        }\n        if (change.from.line === pos.line) {\n          return indexFromPos(change.from) + pos.ch - change.from.ch;\n        }\n        return (\n          indexFromPos(change.from) +\n          sumLengths(change.removed.slice(0, pos.line - change.from.line)) +\n          1 +\n          pos.ch\n        );\n      };\n    }\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      var change = changes[i];\n      indexFromPos = updateIndexFromPos(indexFromPos, change);\n\n      var fromIndex = indexFromPos(change.from);\n      var restLength = docEndLength - fromIndex - sumLengths(change.text);\n\n      operation = new TextOperation()\n        .retain(fromIndex)\n        [\"delete\"](sumLengths(change.removed))\n        .insert(change.text.join(\"\\n\"))\n        .retain(restLength)\n        .compose(operation);\n\n      inverse = inverse.compose(\n        new TextOperation()\n          .retain(fromIndex)\n          [\"delete\"](sumLengths(change.text))\n          .insert(change.removed.join(\"\\n\"))\n          .retain(restLength)\n      );\n\n      docEndLength += sumLengths(change.removed) - sumLengths(change.text);\n    }\n\n    return [operation, inverse];\n  }\n}\n\nfunction cmpPos(a, b) {\n  if (a.line < b.line) {\n    return -1;\n  }\n  if (a.line > b.line) {\n    return 1;\n  }\n  if (a.ch < b.ch) {\n    return -1;\n  }\n  if (a.ch > b.ch) {\n    return 1;\n  }\n  return 0;\n}\nfunction posEq(a, b) {\n  return cmpPos(a, b) === 0;\n}\nfunction posLe(a, b) {\n  return cmpPos(a, b) <= 0;\n}\n\nfunction minPos(a, b) {\n  return posLe(a, b) ? a : b;\n}\nfunction maxPos(a, b) {\n  return posLe(a, b) ? b : a;\n}\n\nfunction codemirrorDocLength(doc) {\n  return (\n    doc.indexFromPos({ line: doc.lastLine(), ch: 0 }) +\n    doc.getLine(doc.lastLine()).length\n  );\n}\n\n// Singular form for backwards compatibility.\n//  CodeMirrorAdapter.operationFromCodeMirrorChange =\n//    CodeMirrorAdapter.operationFromCodeMirrorChanges;\n\nvar addStyleRule = (function () {\n  var added = {};\n  var styleElement = document.createElement(\"style\");\n  document.documentElement\n    .getElementsByTagName(\"head\")[0]\n    .appendChild(styleElement);\n  var styleSheet = styleElement.sheet;\n\n  return function (css) {\n    if (added[css]) {\n      return;\n    }\n    added[css] = true;\n    styleSheet.insertRule(\n      css,\n      (styleSheet.cssRules || styleSheet.rules).length\n    );\n  };\n})();\n\n// Throws an error if the first argument is falsy. Useful for debugging.\nfunction assert(b, msg) {\n  if (!b) {\n    throw new Error(msg || \"assertion error\");\n  }\n}\n\n// Bind a method to an object, so it doesn't matter whether you call\n// object.method() directly or pass object.method as a reference to another\n// function.\nfunction bind(obj, method) {\n  var fn = obj[method];\n  obj[method] = function () {\n    fn.apply(obj, arguments);\n  };\n}\n\nexport default CodeMirrorAdapter;\n","C:\\edi1\\react_type\\react-type\\src\\ot\\socketio-adapter.js",[],"C:\\edi1\\react_type\\react-type\\src\\socket\\socket.ts",[],"C:\\edi1\\react_type\\react-type\\src\\ot\\undo-manager.js",[],"C:\\edi1\\react_type\\react-type\\src\\ot\\client.js",["185"],"// translation of https://github.com/djspiewak/cccp/blob/master/agent/src/main/scala/com/codecommit/cccp/agent/state.scala\n// Client constructor\nclass Client {\n  constructor(revision) {\n    this.revision = revision; // the next expected revision number\n    this.state = synchronized_; // start state\n  }\n  setState(state) {\n    this.state = state;\n  }\n  // Call this method when the user changes the document.\n  applyClient(operation) {\n    this.setState(this.state.applyClient(this, operation));\n  }\n  // Call this method with a new operation from the server\n  applyServer(operation) {\n    this.revision++;\n    this.setState(this.state.applyServer(this, operation));\n  }\n  serverAck() {\n    this.revision++;\n    this.setState(this.state.serverAck(this));\n  }\n  serverReconnect() {\n    if (typeof this.state.resend === \"function\") {\n      this.state.resend(this);\n    }\n  }\n  // Transforms a selection from the latest known server state to the current\n  // client state. For example, if we get from the server the information that\n  // another user's cursor is at position 3, but the server hasn't yet received\n  // our newest operation, an insertion of 5 characters at the beginning of the\n  // document, the correct position of the other user's cursor in our current\n  // document is 8.\n  transformSelection(selection) {\n    return this.state.transformSelection(selection);\n  }\n  // Override this method.\n  sendOperation(revision, operation) {\n    throw new Error(\"sendOperation must be defined in child class\");\n  }\n  // Override this method.\n  applyOperation(operation) {\n    throw new Error(\"applyOperation must be defined in child class\");\n  }\n}\n\n// In the 'Synchronized' state, there is no pending operation that the client\n// has sent to the server.\nclass Synchronized {\n  constructor() {}\n  applyClient(client, operation) {\n    // When the user makes an edit, send the operation to the server and\n    // switch to the 'AwaitingConfirm' state\n    client.sendOperation(client.revision, operation);\n    return new AwaitingConfirm(operation);\n  }\n  applyServer(client, operation) {\n    // When we receive a new operation from the server, the operation can be\n    // simply applied to the current document\n    client.applyOperation(operation);\n    return this;\n  }\n  serverAck(client) {\n    throw new Error(\"There is no pending operation.\");\n  }\n  // Nothing to do because the latest server state and client state are the same.\n  transformSelection(x) {\n    return x;\n  }\n}\nClient.Synchronized = Synchronized;\n\n// Singleton\nvar synchronized_ = new Synchronized();\n\n// In the 'AwaitingConfirm' state, there's one operation the client has sent\n// to the server and is still waiting for an acknowledgement.\nclass AwaitingConfirm {\n  constructor(outstanding) {\n    // Save the pending operation\n    this.outstanding = outstanding;\n  }\n  applyClient(client, operation) {\n    // When the user makes an edit, don't send the operation immediately,\n    // instead switch to 'AwaitingWithBuffer' state\n    return new AwaitingWithBuffer(this.outstanding, operation);\n  }\n  applyServer(client, operation) {\n    // This is another client's operation. Visualization:\n    //\n    //                   /\\\n    // this.outstanding /  \\ operation\n    //                 /    \\\n    //                 \\    /\n    //  pair[1]         \\  / pair[0] (new outstanding)\n    //  (can be applied  \\/\n    //  to the client's\n    //  current document)\n    var pair = operation.constructor.transform(this.outstanding, operation);\n    client.applyOperation(pair[1]);\n    return new AwaitingConfirm(pair[0]);\n  }\n  serverAck(client) {\n    // The client's operation has been acknowledged\n    // => switch to synchronized state\n    return synchronized_;\n  }\n  transformSelection(selection) {\n    return selection.transform(this.outstanding);\n  }\n  resend(client) {\n    // The confirm didn't come because the client was disconnected.\n    // Now that it has reconnected, we resend the outstanding operation.\n    client.sendOperation(client.revision, this.outstanding);\n  }\n}\nClient.AwaitingConfirm = AwaitingConfirm;\n\n// In the 'AwaitingWithBuffer' state, the client is waiting for an operation\n// to be acknowledged by the server while buffering the edits the user makes\nclass AwaitingWithBuffer {\n  constructor(outstanding, buffer) {\n    // Save the pending operation and the user's edits since then\n    this.outstanding = outstanding;\n    this.buffer = buffer;\n  }\n  applyClient(client, operation) {\n    // Compose the user's changes onto the buffer\n    var newBuffer = this.buffer.compose(operation);\n    return new AwaitingWithBuffer(this.outstanding, newBuffer);\n  }\n  applyServer(client, operation) {\n    // Operation comes from another client\n    //\n    //                       /\\\n    //     this.outstanding /  \\ operation\n    //                     /    \\\n    //                    /\\    /\n    //       this.buffer /  \\* / pair1[0] (new outstanding)\n    //                  /    \\/\n    //                  \\    /\n    //          pair2[1] \\  / pair2[0] (new buffer)\n    // the transformed    \\/\n    // operation -- can\n    // be applied to the\n    // client's current\n    // document\n    //\n    // * pair1[1]\n    var transform = operation.constructor.transform;\n    var pair1 = transform(this.outstanding, operation);\n    var pair2 = transform(this.buffer, pair1[1]);\n    client.applyOperation(pair2[1]);\n    return new AwaitingWithBuffer(pair1[0], pair2[0]);\n  }\n  serverAck(client) {\n    // The pending operation has been acknowledged\n    // => send buffer\n    client.sendOperation(client.revision, this.buffer);\n    return new AwaitingConfirm(this.buffer);\n  }\n  transformSelection(selection) {\n    return selection.transform(this.outstanding).transform(this.buffer);\n  }\n  resend(client) {\n    // The confirm didn't come because the client was disconnected.\n    // Now that it has reconnected, we resend the outstanding operation.\n    client.sendOperation(client.revision, this.outstanding);\n  }\n}\nClient.AwaitingWithBuffer = AwaitingWithBuffer;\n\nexport default Client;\n","C:\\edi1\\react_type\\react-type\\src\\ot\\wrapped-operation.js",[],"C:\\edi1\\react_type\\react-type\\src\\ot\\text-operation.js",["186"],"// Constructor for new operations.\nclass TextOperation {\n  constructor() {\n    if (!this || this.constructor !== TextOperation) {\n      // => function was called without 'new'\n      return new TextOperation();\n    }\n    // When an operation is applied to an input string, you can think of this as\n    // if an imaginary cursor runs over the entire string and skips over some\n    // parts, deletes some parts and inserts characters at some positions. These\n    // actions (skip/delete/insert) are stored as an array in the \"ops\" property.\n    this.ops = [];\n    // An operation's baseLength is the length of every string the operation\n    // can be applied to.\n    this.baseLength = 0;\n    // The targetLength is the length of every string that results from applying\n    // the operation on a valid input string.\n    this.targetLength = 0;\n  }\n  equals(other) {\n    if (this.baseLength !== other.baseLength) {\n      return false;\n    }\n    if (this.targetLength !== other.targetLength) {\n      return false;\n    }\n    if (this.ops.length !== other.ops.length) {\n      return false;\n    }\n    for (var i = 0; i < this.ops.length; i++) {\n      if (this.ops[i] !== other.ops[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // After an operation is constructed, the user of the library can specify the\n  // actions of an operation (skip/insert/delete) with these three builder\n  // methods. They all return the operation for convenient chaining.\n  // Skip over a given number of characters.\n  retain(n) {\n    if (typeof n !== \"number\") {\n      throw new Error(\"retain expects an integer\");\n    }\n    if (n === 0) {\n      return this;\n    }\n    this.baseLength += n;\n    this.targetLength += n;\n    if (TextOperation.isRetain(this.ops[this.ops.length - 1])) {\n      // The last op is a retain op => we can merge them into one op.\n      this.ops[this.ops.length - 1] += n;\n    } else {\n      // Create a new op.\n      this.ops.push(n);\n    }\n    return this;\n  }\n  // Insert a string at the current position.\n  insert(str) {\n    if (typeof str !== \"string\") {\n      throw new Error(\"insert expects a string\");\n    }\n    if (str === \"\") {\n      return this;\n    }\n    this.targetLength += str.length;\n    var ops = this.ops;\n    if (TextOperation.isInsert(ops[ops.length - 1])) {\n      // Merge insert op.\n      ops[ops.length - 1] += str;\n    } else if (TextOperation.isDelete(ops[ops.length - 1])) {\n      // It doesn't matter when an operation is applied whether the operation\n      // is delete(3), insert(\"something\") or insert(\"something\"), delete(3).\n      // Here we enforce that in this case, the insert op always comes first.\n      // This makes all operations that have the same effect when applied to\n      // a document of the right length equal in respect to the `equals` method.\n      if (TextOperation.isInsert(ops[ops.length - 2])) {\n        ops[ops.length - 2] += str;\n      } else {\n        ops[ops.length] = ops[ops.length - 1];\n        ops[ops.length - 2] = str;\n      }\n    } else {\n      ops.push(str);\n    }\n    return this;\n  }\n  // Delete a string at the current position.\n  delete(n) {\n    if (typeof n === \"string\") {\n      n = n.length;\n    }\n    if (typeof n !== \"number\") {\n      throw new Error(\"delete expects an integer or a string\");\n    }\n    if (n === 0) {\n      return this;\n    }\n    if (n > 0) {\n      n = -n;\n    }\n    this.baseLength -= n;\n    if (TextOperation.isDelete(this.ops[this.ops.length - 1])) {\n      this.ops[this.ops.length - 1] += n;\n    } else {\n      this.ops.push(n);\n    }\n    return this;\n  }\n  // Tests whether this operation has no effect.\n  isNoop() {\n    return (\n      this.ops.length === 0 ||\n      (this.ops.length === 1 && TextOperation.isRetain(this.ops[0]))\n    );\n  }\n  // Pretty printing.\n  toString() {\n    // map: build a new array by applying a function to every element in an old\n    // array.\n    var map =\n      Array.prototype.map ||\n      function (fn) {\n        var arr = this;\n        var newArr = [];\n        for (var i = 0, l = arr.length; i < l; i++) {\n          newArr[i] = fn(arr[i]);\n        }\n        return newArr;\n      };\n    return map\n      .call(this.ops, function (op) {\n        if (TextOperation.isRetain(op)) {\n          return \"retain \" + op;\n        } else if (TextOperation.isInsert(op)) {\n          return \"insert '\" + op + \"'\";\n        } else {\n          return \"delete \" + -op;\n        }\n      })\n      .join(\", \");\n  }\n  // Converts operation into a JSON value.\n  toJSON() {\n    return this.ops;\n  }\n  // Apply an operation to a string, returning a new string. Throws an error if\n  // there's a mismatch between the input string and the operation.\n  apply(str) {\n    var operation = this;\n    if (str.length !== operation.baseLength) {\n      throw new Error(\n        \"The operation's base length must be equal to the string's length.\"\n      );\n    }\n    var newStr = [],\n      j = 0;\n    var strIndex = 0;\n    var ops = this.ops;\n    for (var i = 0, l = ops.length; i < l; i++) {\n      var op = ops[i];\n      if (TextOperation.isRetain(op)) {\n        if (strIndex + op > str.length) {\n          throw new Error(\n            \"Operation can't retain more characters than are left in the string.\"\n          );\n        }\n        // Copy skipped part of the old string.\n        newStr[j++] = str.slice(strIndex, strIndex + op);\n        strIndex += op;\n      } else if (TextOperation.isInsert(op)) {\n        // Insert string.\n        newStr[j++] = op;\n      } else {\n        // delete op\n        strIndex -= op;\n      }\n    }\n    if (strIndex !== str.length) {\n      throw new Error(\"The operation didn't operate on the whole string.\");\n    }\n    return newStr.join(\"\");\n  }\n  // Computes the inverse of an operation. The inverse of an operation is the\n  // operation that reverts the effects of the operation, e.g. when you have an\n  // operation 'insert(\"hello \"); skip(6);' then the inverse is 'delete(\"hello \");\n  // skip(6);'. The inverse should be used for implementing undo.\n  invert(str) {\n    var strIndex = 0;\n    var inverse = new TextOperation();\n    var ops = this.ops;\n    for (var i = 0, l = ops.length; i < l; i++) {\n      var op = ops[i];\n      if (TextOperation.isRetain(op)) {\n        inverse.retain(op);\n        strIndex += op;\n      } else if (TextOperation.isInsert(op)) {\n        inverse[\"delete\"](op.length);\n      } else {\n        // delete op\n        inverse.insert(str.slice(strIndex, strIndex - op));\n        strIndex -= op;\n      }\n    }\n    return inverse;\n  }\n  // Compose merges two consecutive operations into one operation, that\n  // preserves the changes of both. Or, in other words, for each input string S\n  // and a pair of consecutive operations A and B,\n  // apply(apply(S, A), B) = apply(S, compose(A, B)) must hold.\n  compose(operation2) {\n    var operation1 = this;\n    if (operation1.targetLength !== operation2.baseLength) {\n      throw new Error(\n        \"The base length of the second operation has to be the target length of the first operation\"\n      );\n    }\n\n    var operation = new TextOperation(); // the combined operation\n    var ops1 = operation1.ops,\n      ops2 = operation2.ops; // for fast access\n    var i1 = 0,\n      i2 = 0; // current index into ops1 respectively ops2\n    var op1 = ops1[i1++],\n      op2 = ops2[i2++]; // current ops\n    while (true) {\n      // Dispatch on the type of op1 and op2\n      if (typeof op1 === \"undefined\" && typeof op2 === \"undefined\") {\n        // end condition: both ops1 and ops2 have been processed\n        break;\n      }\n\n      if (TextOperation.isDelete(op1)) {\n        operation[\"delete\"](op1);\n        op1 = ops1[i1++];\n        continue;\n      }\n      if (TextOperation.isInsert(op2)) {\n        operation.insert(op2);\n        op2 = ops2[i2++];\n        continue;\n      }\n\n      if (typeof op1 === \"undefined\") {\n        throw new Error(\n          \"Cannot compose operations: first operation is too short.\"\n        );\n      }\n      if (typeof op2 === \"undefined\") {\n        throw new Error(\n          \"Cannot compose operations: first operation is too long.\"\n        );\n      }\n\n      if (TextOperation.isRetain(op1) && TextOperation.isRetain(op2)) {\n        if (op1 > op2) {\n          operation.retain(op2);\n          op1 = op1 - op2;\n          op2 = ops2[i2++];\n        } else if (op1 === op2) {\n          operation.retain(op1);\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          operation.retain(op1);\n          op2 = op2 - op1;\n          op1 = ops1[i1++];\n        }\n      } else if (TextOperation.isInsert(op1) && TextOperation.isDelete(op2)) {\n        if (op1.length > -op2) {\n          op1 = op1.slice(-op2);\n          op2 = ops2[i2++];\n        } else if (op1.length === -op2) {\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          op2 = op2 + op1.length;\n          op1 = ops1[i1++];\n        }\n      } else if (TextOperation.isInsert(op1) && TextOperation.isRetain(op2)) {\n        if (op1.length > op2) {\n          operation.insert(op1.slice(0, op2));\n          op1 = op1.slice(op2);\n          op2 = ops2[i2++];\n        } else if (op1.length === op2) {\n          operation.insert(op1);\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          operation.insert(op1);\n          op2 = op2 - op1.length;\n          op1 = ops1[i1++];\n        }\n      } else if (TextOperation.isRetain(op1) && TextOperation.isDelete(op2)) {\n        if (op1 > -op2) {\n          operation[\"delete\"](op2);\n          op1 = op1 + op2;\n          op2 = ops2[i2++];\n        } else if (op1 === -op2) {\n          operation[\"delete\"](op2);\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          operation[\"delete\"](op1);\n          op2 = op2 + op1;\n          op1 = ops1[i1++];\n        }\n      } else {\n        throw new Error(\n          \"This shouldn't happen: op1: \" +\n            JSON.stringify(op1) +\n            \", op2: \" +\n            JSON.stringify(op2)\n        );\n      }\n    }\n    return operation;\n  }\n  // When you use ctrl-z to undo your latest changes, you expect the program not\n  // to undo every single keystroke but to undo your last sentence you wrote at\n  // a stretch or the deletion you did by holding the backspace key down. This\n  // This can be implemented by composing operations on the undo stack. This\n  // method can help decide whether two operations should be composed. It\n  // returns true if the operations are consecutive insert operations or both\n  // operations delete text at the same position. You may want to include other\n  // factors like the time since the last change in your decision.\n  shouldBeComposedWith(other) {\n    if (this.isNoop() || other.isNoop()) {\n      return true;\n    }\n\n    var startA = getStartIndex(this),\n      startB = getStartIndex(other);\n    var simpleA = getSimpleOp(this),\n      simpleB = getSimpleOp(other);\n    if (!simpleA || !simpleB) {\n      return false;\n    }\n\n    if (TextOperation.isInsert(simpleA) && TextOperation.isInsert(simpleB)) {\n      return startA + simpleA.length === startB;\n    }\n\n    if (TextOperation.isDelete(simpleA) && TextOperation.isDelete(simpleB)) {\n      // there are two possibilities to delete: with backspace and with the\n      // delete key.\n      return startB - simpleB === startA || startA === startB;\n    }\n\n    return false;\n  }\n  // Decides whether two operations should be composed with each other\n  // if they were inverted, that is\n  // `shouldBeComposedWith(a, b) = shouldBeComposedWithInverted(b^{-1}, a^{-1})`.\n  shouldBeComposedWithInverted(other) {\n    if (this.isNoop() || other.isNoop()) {\n      return true;\n    }\n\n    var startA = getStartIndex(this),\n      startB = getStartIndex(other);\n    var simpleA = getSimpleOp(this),\n      simpleB = getSimpleOp(other);\n    if (!simpleA || !simpleB) {\n      return false;\n    }\n\n    if (TextOperation.isInsert(simpleA) && TextOperation.isInsert(simpleB)) {\n      return startA + simpleA.length === startB || startA === startB;\n    }\n\n    if (TextOperation.isDelete(simpleA) && TextOperation.isDelete(simpleB)) {\n      return startB - simpleB === startA;\n    }\n\n    return false;\n  }\n  static isRetain(op) {\n    return typeof op === \"number\" && op > 0;\n  }\n  static isInsert(op) {\n    return typeof op === \"string\";\n  }\n  static isDelete(op) {\n    return typeof op === \"number\" && op < 0;\n  }\n  // Converts a plain JS object into an operation and validates it.\n  static fromJSON(ops) {\n    var o = new TextOperation();\n    for (var i = 0, l = ops.length; i < l; i++) {\n      var op = ops[i];\n      if (TextOperation.isRetain(op)) {\n        o.retain(op);\n      } else if (TextOperation.isInsert(op)) {\n        o.insert(op);\n      } else if (TextOperation.isDelete(op)) {\n        o[\"delete\"](op);\n      } else {\n        throw new Error(\"unknown operation: \" + JSON.stringify(op));\n      }\n    }\n    return o;\n  }\n  // Transform takes two operations A and B that happened concurrently and\n  // produces two operations A' and B' (in an array) such that\n  // `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the\n  // heart of OT.\n  static transform(operation1, operation2) {\n    if (operation1.baseLength !== operation2.baseLength) {\n      throw new Error(\"Both operations have to have the same base length\");\n    }\n\n    var operation1prime = new TextOperation();\n    var operation2prime = new TextOperation();\n    var ops1 = operation1.ops,\n      ops2 = operation2.ops;\n    var i1 = 0,\n      i2 = 0;\n    var op1 = ops1[i1++],\n      op2 = ops2[i2++];\n    while (true) {\n      // At every iteration of the loop, the imaginary cursor that both\n      // operation1 and operation2 have that operates on the input string must\n      // have the same position in the input string.\n      if (typeof op1 === \"undefined\" && typeof op2 === \"undefined\") {\n        // end condition: both ops1 and ops2 have been processed\n        break;\n      }\n\n      // next two cases: one or both ops are insert ops\n      // => insert the string in the corresponding prime operation, skip it in\n      // the other one. If both op1 and op2 are insert ops, prefer op1.\n      if (TextOperation.isInsert(op1)) {\n        operation1prime.insert(op1);\n        operation2prime.retain(op1.length);\n        op1 = ops1[i1++];\n        continue;\n      }\n      if (TextOperation.isInsert(op2)) {\n        operation1prime.retain(op2.length);\n        operation2prime.insert(op2);\n        op2 = ops2[i2++];\n        continue;\n      }\n\n      if (typeof op1 === \"undefined\") {\n        throw new Error(\n          \"Cannot compose operations: first operation is too short.\"\n        );\n      }\n      if (typeof op2 === \"undefined\") {\n        throw new Error(\n          \"Cannot compose operations: first operation is too long.\"\n        );\n      }\n\n      var minl;\n      if (TextOperation.isRetain(op1) && TextOperation.isRetain(op2)) {\n        // Simple case: retain/retain\n        if (op1 > op2) {\n          minl = op2;\n          op1 = op1 - op2;\n          op2 = ops2[i2++];\n        } else if (op1 === op2) {\n          minl = op2;\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          minl = op1;\n          op2 = op2 - op1;\n          op1 = ops1[i1++];\n        }\n        operation1prime.retain(minl);\n        operation2prime.retain(minl);\n      } else if (TextOperation.isDelete(op1) && TextOperation.isDelete(op2)) {\n        // Both operations delete the same string at the same position. We don't\n        // need to produce any operations, we just skip over the delete ops and\n        // handle the case that one operation deletes more than the other.\n        if (-op1 > -op2) {\n          op1 = op1 - op2;\n          op2 = ops2[i2++];\n        } else if (op1 === op2) {\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          op2 = op2 - op1;\n          op1 = ops1[i1++];\n        }\n        // next two cases: delete/retain and retain/delete\n      } else if (TextOperation.isDelete(op1) && TextOperation.isRetain(op2)) {\n        if (-op1 > op2) {\n          minl = op2;\n          op1 = op1 + op2;\n          op2 = ops2[i2++];\n        } else if (-op1 === op2) {\n          minl = op2;\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          minl = -op1;\n          op2 = op2 + op1;\n          op1 = ops1[i1++];\n        }\n        operation1prime[\"delete\"](minl);\n      } else if (TextOperation.isRetain(op1) && TextOperation.isDelete(op2)) {\n        if (op1 > -op2) {\n          minl = -op2;\n          op1 = op1 + op2;\n          op2 = ops2[i2++];\n        } else if (op1 === -op2) {\n          minl = op1;\n          op1 = ops1[i1++];\n          op2 = ops2[i2++];\n        } else {\n          minl = op1;\n          op2 = op2 + op1;\n          op1 = ops1[i1++];\n        }\n        operation2prime[\"delete\"](minl);\n      } else {\n        throw new Error(\"The two operations aren't compatible\");\n      }\n    }\n\n    return [operation1prime, operation2prime];\n  }\n}\n\n// Operation are essentially lists of ops. There are three types of ops:\n//\n// * Retain ops: Advance the cursor position by a given number of characters.\n//   Represented by positive ints.\n// * Insert ops: Insert a given string at the current cursor position.\n//   Represented by strings.\n// * Delete ops: Delete the next n characters. Represented by negative ints.\n\nfunction getSimpleOp(operation, fn) {\n  var ops = operation.ops;\n  //var isRetain = TextOperation.isRetain;\n  switch (ops.length) {\n    case 1:\n      return ops[0];\n    case 2:\n      return TextOperation.isRetain(ops[0])\n        ? ops[1]\n        : TextOperation.isRetain(ops[1])\n        ? ops[0]\n        : null;\n    case 3:\n      if (TextOperation.isRetain(ops[0]) && TextOperation.isRetain(ops[2])) {\n        return ops[1];\n      }\n  }\n  return null;\n}\n\nfunction getStartIndex(operation) {\n  if (TextOperation.isRetain(operation.ops[0])) {\n    return operation.ops[0];\n  }\n  return 0;\n}\n\nexport default TextOperation;\n","C:\\edi1\\react_type\\react-type\\src\\ot\\selection.js",[],"C:\\edi1\\react_type\\react-type\\src\\utils\\WindowAddon.ts",[],"C:\\edi1\\react_type\\react-type\\src\\components\\codeEditor\\codeEditor.tsx",["187"],"import React, { useState, useEffect, ChangeEvent } from \"react\";\r\nimport { Editor } from \"codemirror\";\r\nimport { Flex, FormControl, Select } from \"@chakra-ui/react\";\r\nimport \"codemirror/theme/monokai.css\";\r\nimport \"codemirror/lib/codemirror.css\";\r\nimport \"codemirror/mode/javascript/javascript\";\r\nimport { UnControlled as CodeMirrorEditor } from \"react-codemirror2\";\r\nimport { socket } from \"../../socket/socket\";\r\nimport EditorClient from \"../../ot/editor-client\";\r\nimport CodeMirrorAdapter from \"../../ot/codemirror-adapter\";\r\nimport SocketIOAdapter from \"../../ot/socketio-adapter\";\r\nimport WindowAddon from \"../../utils/WindowAddon\";\r\n\r\ninterface Document {\r\n  str: string;\r\n  revision: number;\r\n  clients: any;\r\n}\r\ninterface Update {\r\n  document: string;\r\n  language: number;\r\n}\r\n\r\nconst CodeEditor: React.FC = () => {\r\n  const [language, setLanguage] = useState<number | string>(0);\r\n  var editor1: Editor;\r\n\r\n  //*******************************************************************\r\n\r\n  const handleChange = (e: ChangeEvent<HTMLSelectElement>) => {\r\n    setLanguage(e.target.value);\r\n    socket.emit(\"changeLanguage\", {\r\n      room: \"room\",\r\n      language: e.target.value,\r\n    });\r\n  };\r\n  const InitilizeEditor = (document: Document) => {\r\n    if (editor1 != undefined) {\r\n      editor1.setValue(document.str);\r\n      WindowAddon.cmClient = new EditorClient(\r\n        document.revision,\r\n        document.clients,\r\n        new SocketIOAdapter(socket),\r\n        new CodeMirrorAdapter(editor1)\r\n      );\r\n    }\r\n  };\r\n\r\n  //###########################################################\r\n\r\n  socket.on(\"update__\", (document: Update) => {\r\n    WindowAddon.update(document.document);\r\n    setLanguage(document.language);\r\n  });\r\n  socket.on(\"doc\", (document: Document) => {\r\n    InitilizeEditor(document);\r\n  });\r\n  socket.on(\"updateLanguage\", (language: number) => {\r\n    setLanguage(language);\r\n  });\r\n\r\n  //###########################################################\r\n\r\n  useEffect(() => {\r\n    socket.emit(\"joinRoom\", { room: \"room\", username: Date.now().toString() });\r\n  }, []);\r\n\r\n  //*******************************************************************\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <div>\r\n        <Flex direction=\"row\" justifyContent=\"flex-end\" padding=\"1\">\r\n          <FormControl w=\"10vw\" marginRight=\"3\">\r\n            <Select\r\n              borderColor=\"cyan.300\"\r\n              borderWidth=\"medium\"\r\n              bg=\"cyan.100\"\r\n              value={language}\r\n              onChange={(e) => handleChange(e)}\r\n            >\r\n              <option value={0}>C++</option>\r\n              <option value={1}>Javascript</option>\r\n              <option value={2}>Java</option>\r\n              <option value={3}>Python</option>\r\n            </Select>\r\n          </FormControl>\r\n        </Flex>\r\n        <div style={{ fontSize: \"20px\" }}>\r\n          <CodeMirrorEditor\r\n            editorDidMount={(editor: Editor) => {\r\n              editor.setSize(\"100%\", \"85vh\");\r\n              editor1 = editor;\r\n            }}\r\n            options={{\r\n              theme: \"monokai\",\r\n              lineNumbers: true,\r\n              lineWrapping: true,\r\n            }}\r\n          />\r\n        </div>\r\n      </div>\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default CodeEditor;\r\n","C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\WhiteBoard.tsx",["188","189","190","191","192","193","194"],"import React, { useState, useEffect, ChangeEvent } from \"react\";\r\nimport { Flex, FormControl, Select, Stack } from \"@chakra-ui/react\";\r\nimport Container from \"./Containter\";\r\n\r\nconst WhiteBoard: React.FC = () => {\r\n  return (\r\n    <React.Fragment>\r\n      <Container />\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default WhiteBoard;\r\n","C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\Containter.tsx",[],"C:\\edi1\\react_type\\react-type\\src\\components\\whiteBoard\\Board.tsx",["195"],"import React from \"react\";\r\nimport { socket } from \"../../socket/socket\";\r\nimport { Socket } from \"socket.io-client\";\r\nimport { SendCursorPosition } from \"../../socket/socketEvents\";\r\nimport { Operation, Props } from \"../../types\";\r\nclass Board extends React.Component<Props> {\r\n  timeout: any;\r\n  socket: Socket;\r\n  ctx: any;\r\n  isDrawing = false;\r\n  leftt: number;\r\n  topp: number;\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.socket = socket;\r\n    this.leftt = props.lef;\r\n    this.topp = props.top;\r\n    this.socket.on(\"new_operation\", (operation: Operation) => {\r\n      this.applyNewOperation(operation);\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.drawOnCanvas();\r\n  }\r\n\r\n  componentWillReceiveProps(newProps: Props) {\r\n    this.leftt = newProps.lef;\r\n    this.topp = newProps.top;\r\n    this.ctx.strokeStyle = newProps.color;\r\n    this.ctx.lineWidth = newProps.size;\r\n  }\r\n\r\n  applyNewOperation(operation: Operation) {\r\n    if (this.ctx === undefined) return;\r\n    let myColor = this.ctx.strokeStyle;\r\n    let mySize = this.ctx.lineWidth;\r\n    this.ctx.strokeStyle = operation.color;\r\n    this.ctx.lineWidth = operation.size;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(operation.from.x, operation.from.y);\r\n    this.ctx.lineTo(operation.to.x, operation.to.y);\r\n    this.ctx.closePath();\r\n    this.ctx.stroke();\r\n    this.ctx.strokeStyle = myColor;\r\n    this.ctx.lineWidth = mySize;\r\n  }\r\n\r\n  drawOnCanvas() {\r\n    var root = this;\r\n    var canvas = document.querySelector(\"#board\");\r\n    //@ts-ignore\r\n    this.ctx = canvas?.getContext(\"2d\");\r\n    var ctx = this.ctx;\r\n    var sketch = document.querySelector(\"#sketch\");\r\n    //@ts-ignore\r\n    var sketch_style = getComputedStyle(sketch);\r\n    //@ts-ignore\r\n    canvas.width = parseInt(sketch_style.getPropertyValue(\"width\"));\r\n    //@ts-ignore\r\n    canvas.height = parseInt(sketch_style.getPropertyValue(\"height\"));\r\n\r\n    var mouse = { x: 0, y: 0 };\r\n    var last_mouse = { x: 0, y: 0 };\r\n\r\n    /* Mouse Capturing Work */\r\n\r\n    //@ts-ignore\r\n    canvas.addEventListener(\r\n      \"mousemove\",\r\n      function (e) {\r\n        last_mouse.x = mouse.x;\r\n        last_mouse.y = mouse.y;\r\n        //@ts-ignore\r\n        mouse.x = e.pageX - this.offsetLeft;\r\n        //@ts-ignore\r\n        mouse.y = e.pageY - this.offsetTop;\r\n        //@ts-ignore\r\n      },\r\n      false\r\n    );\r\n\r\n    /* Drawing on Paint App */\r\n    //@ts-ignore\r\n    ctx.lineWidth = this.props.size;\r\n    ctx.lineJoin = \"round\";\r\n    ctx.lineCap = \"round\";\r\n    //@ts-ignore\r\n    ctx.strokeStyle = this.props.color;\r\n    //@ts-ignore\r\n    canvas.addEventListener(\r\n      \"mousedown\",\r\n      function (e) {\r\n        //@ts-ignore\r\n        canvas.addEventListener(\"mousemove\", onPaint, false);\r\n      },\r\n      false\r\n    );\r\n    //@ts-ignore\r\n    canvas.addEventListener(\r\n      \"mouseup\",\r\n      function () {\r\n        //@ts-ignore\r\n        canvas.removeEventListener(\"mousemove\", onPaint, false);\r\n      },\r\n      false\r\n    );\r\n\r\n    var onPaint = function () {\r\n      ctx.beginPath();\r\n      ctx.moveTo(last_mouse.x, last_mouse.y);\r\n      ctx.lineTo(mouse.x, mouse.y);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n\r\n      root.socket.emit(\"draw_operation\", {\r\n        color: root.ctx.strokeStyle,\r\n        size: root.ctx.lineWidth,\r\n        from: { x: last_mouse.x, y: last_mouse.y },\r\n        to: { x: mouse.x, y: mouse.y },\r\n      });\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"sketch\" id=\"sketch\">\r\n        <canvas className=\"board\" id=\"board\"></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","C:\\edi1\\react_type\\react-type\\src\\components\\Appbar\\Appbar.tsx",["196","197","198","199","200"],"import React, { useState, useEffect, ChangeEvent } from \"react\";\r\nimport { Flex, IconButton } from \"@chakra-ui/react\";\r\nimport { PhoneIcon } from \"@chakra-ui/icons\";\r\nimport { AppBar, Toolbar } from \"@material-ui/core\";\r\n\r\nconst AppHeaderBar: React.FC = () => {\r\n  return (\r\n    <React.Fragment>\r\n      <Flex>\r\n        <AppBar variant=\"outlined\" position=\"static\">\r\n          <Toolbar variant=\"dense\">Code</Toolbar>\r\n        </AppBar>\r\n      </Flex>\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default AppHeaderBar;\r\n","C:\\edi1\\react_type\\react-type\\src\\components\\Footer\\Footer.tsx",["201","202","203","204","205"],"C:\\edi1\\react_type\\react-type\\src\\socket\\socketEvents.ts",[],["206","207"],"C:\\edi1\\react_type\\react-type\\src\\components\\Video\\Video.tsx",["208","209","210"],"C:\\edi1\\Collab\\frontend\\src\\index.tsx",[],"C:\\edi1\\Collab\\frontend\\src\\App.tsx",["211","212","213","214","215","216"],"C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\WhiteBoard.tsx",["217","218","219","220","221","222","223"],"C:\\edi1\\Collab\\frontend\\src\\components\\Appbar\\Appbar.tsx",["224","225","226","227","228"],"C:\\edi1\\Collab\\frontend\\src\\components\\codeEditor\\codeEditor.tsx",["229"],"C:\\edi1\\Collab\\frontend\\src\\components\\Video\\Video.tsx",["230","231","232"],"C:\\edi1\\Collab\\frontend\\src\\ot\\codemirror-adapter.js",["233","234"],"C:\\edi1\\Collab\\frontend\\src\\ot\\socketio-adapter.js",[],"C:\\edi1\\Collab\\frontend\\src\\ot\\editor-client.js",["235","236"],"C:\\edi1\\Collab\\frontend\\src\\socket\\socket.ts",[],"C:\\edi1\\Collab\\frontend\\src\\utils\\WindowAddon.ts",[],"C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\Containter.tsx",[],"C:\\edi1\\Collab\\frontend\\src\\ot\\selection.js",[],"C:\\edi1\\Collab\\frontend\\src\\ot\\text-operation.js",["237"],"C:\\edi1\\Collab\\frontend\\src\\ot\\wrapped-operation.js",[],"C:\\edi1\\Collab\\frontend\\src\\ot\\undo-manager.js",[],"C:\\edi1\\Collab\\frontend\\src\\ot\\client.js",["238"],"C:\\edi1\\Collab\\frontend\\src\\components\\whiteBoard\\Board.tsx",["239"],{"ruleId":"240","replacedBy":"241"},{"ruleId":"242","replacedBy":"243"},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"250","line":3,"column":16,"nodeType":"246","messageId":"247","endLine":3,"endColumn":27},{"ruleId":"244","severity":1,"message":"251","line":3,"column":29,"nodeType":"246","messageId":"247","endLine":3,"endColumn":35},{"ruleId":"244","severity":1,"message":"252","line":7,"column":8,"nodeType":"246","messageId":"247","endLine":7,"endColumn":14},{"ruleId":"253","severity":1,"message":"254","line":31,"column":7,"nodeType":"246","messageId":"247","endLine":31,"endColumn":16},{"ruleId":"253","severity":1,"message":"255","line":275,"column":9,"nodeType":"246","messageId":"247","endLine":275,"endColumn":18},{"ruleId":"240","replacedBy":"241"},{"ruleId":"242","replacedBy":"243"},{"ruleId":"253","severity":1,"message":"256","line":424,"column":10,"nodeType":"246","messageId":"247","endLine":424,"endColumn":15},{"ruleId":"253","severity":1,"message":"257","line":470,"column":10,"nodeType":"246","messageId":"247","endLine":470,"endColumn":16},{"ruleId":"258","severity":1,"message":"259","line":51,"column":3,"nodeType":"260","messageId":"261","endLine":51,"endColumn":19},{"ruleId":"262","severity":1,"message":"263","line":541,"column":3,"nodeType":"264","messageId":"265","endLine":554,"endColumn":4},{"ruleId":"266","severity":1,"message":"267","line":38,"column":17,"nodeType":"268","messageId":"269","endLine":38,"endColumn":19},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"270","line":2,"column":10,"nodeType":"246","messageId":"247","endLine":2,"endColumn":14},{"ruleId":"244","severity":1,"message":"250","line":2,"column":16,"nodeType":"246","messageId":"247","endLine":2,"endColumn":27},{"ruleId":"244","severity":1,"message":"251","line":2,"column":29,"nodeType":"246","messageId":"247","endLine":2,"endColumn":35},{"ruleId":"244","severity":1,"message":"271","line":2,"column":37,"nodeType":"246","messageId":"247","endLine":2,"endColumn":42},{"ruleId":"244","severity":1,"message":"272","line":4,"column":10,"nodeType":"246","messageId":"247","endLine":4,"endColumn":28},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"273","line":2,"column":16,"nodeType":"246","messageId":"247","endLine":2,"endColumn":26},{"ruleId":"244","severity":1,"message":"274","line":3,"column":10,"nodeType":"246","messageId":"247","endLine":3,"endColumn":19},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"270","line":2,"column":10,"nodeType":"246","messageId":"247","endLine":2,"endColumn":14},{"ruleId":"244","severity":1,"message":"273","line":2,"column":16,"nodeType":"246","messageId":"247","endLine":2,"endColumn":26},{"ruleId":"240","replacedBy":"275"},{"ruleId":"242","replacedBy":"276"},{"ruleId":"244","severity":1,"message":"245","line":2,"column":17,"nodeType":"246","messageId":"247","endLine":2,"endColumn":25},{"ruleId":"244","severity":1,"message":"277","line":2,"column":38,"nodeType":"246","messageId":"247","endLine":2,"endColumn":44},{"ruleId":"244","severity":1,"message":"278","line":9,"column":11,"nodeType":"246","messageId":"247","endLine":9,"endColumn":13},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"250","line":3,"column":16,"nodeType":"246","messageId":"247","endLine":3,"endColumn":27},{"ruleId":"244","severity":1,"message":"251","line":3,"column":29,"nodeType":"246","messageId":"247","endLine":3,"endColumn":35},{"ruleId":"244","severity":1,"message":"252","line":7,"column":8,"nodeType":"246","messageId":"247","endLine":7,"endColumn":14},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"270","line":2,"column":10,"nodeType":"246","messageId":"247","endLine":2,"endColumn":14},{"ruleId":"244","severity":1,"message":"250","line":2,"column":16,"nodeType":"246","messageId":"247","endLine":2,"endColumn":27},{"ruleId":"244","severity":1,"message":"251","line":2,"column":29,"nodeType":"246","messageId":"247","endLine":2,"endColumn":35},{"ruleId":"244","severity":1,"message":"271","line":2,"column":37,"nodeType":"246","messageId":"247","endLine":2,"endColumn":42},{"ruleId":"244","severity":1,"message":"245","line":1,"column":17,"nodeType":"246","messageId":"247","endLine":1,"endColumn":25},{"ruleId":"244","severity":1,"message":"248","line":1,"column":27,"nodeType":"246","messageId":"247","endLine":1,"endColumn":36},{"ruleId":"244","severity":1,"message":"249","line":1,"column":38,"nodeType":"246","messageId":"247","endLine":1,"endColumn":49},{"ruleId":"244","severity":1,"message":"273","line":2,"column":16,"nodeType":"246","messageId":"247","endLine":2,"endColumn":26},{"ruleId":"244","severity":1,"message":"274","line":3,"column":10,"nodeType":"246","messageId":"247","endLine":3,"endColumn":19},{"ruleId":"266","severity":1,"message":"267","line":38,"column":17,"nodeType":"268","messageId":"269","endLine":38,"endColumn":19},{"ruleId":"244","severity":1,"message":"245","line":2,"column":17,"nodeType":"246","messageId":"247","endLine":2,"endColumn":25},{"ruleId":"244","severity":1,"message":"277","line":2,"column":38,"nodeType":"246","messageId":"247","endLine":2,"endColumn":44},{"ruleId":"244","severity":1,"message":"278","line":9,"column":11,"nodeType":"246","messageId":"247","endLine":9,"endColumn":13},{"ruleId":"253","severity":1,"message":"256","line":424,"column":10,"nodeType":"246","messageId":"247","endLine":424,"endColumn":15},{"ruleId":"253","severity":1,"message":"257","line":470,"column":10,"nodeType":"246","messageId":"247","endLine":470,"endColumn":16},{"ruleId":"253","severity":1,"message":"254","line":31,"column":7,"nodeType":"246","messageId":"247","endLine":31,"endColumn":16},{"ruleId":"253","severity":1,"message":"255","line":275,"column":9,"nodeType":"246","messageId":"247","endLine":275,"endColumn":18},{"ruleId":"262","severity":1,"message":"263","line":541,"column":3,"nodeType":"264","messageId":"265","endLine":554,"endColumn":4},{"ruleId":"258","severity":1,"message":"259","line":51,"column":3,"nodeType":"260","messageId":"261","endLine":51,"endColumn":19},{"ruleId":"244","severity":1,"message":"272","line":4,"column":10,"nodeType":"246","messageId":"247","endLine":4,"endColumn":28},"no-native-reassign",["279"],"no-negated-in-lhs",["280"],"@typescript-eslint/no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","'ChangeEvent' is defined but never used.","'FormControl' is defined but never used.","'Select' is defined but never used.","'Footer' is defined but never used.","no-unused-vars","'OtherMeta' is defined but never used.","'operation' is assigned a value but never used.","'posEq' is defined but never used.","'assert' is defined but never used.","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'Flex' is defined but never used.","'Stack' is defined but never used.","'SendCursorPosition' is defined but never used.","'IconButton' is defined but never used.","'PhoneIcon' is defined but never used.",["279"],["280"],"'useRef' is defined but never used.","'Vi' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]